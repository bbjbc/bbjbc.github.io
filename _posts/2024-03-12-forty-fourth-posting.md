---
title: "[Algorithm] 게임 맵 최단거리"
categories: [algorithm]
tags: [algorithm, programmers, Lv2, 깊이/너비 우선 탐색(DFS/BFS)]
author-profile: true
sidebar_main: true
main: true
toc: true
toc_sticky: true
---

# 마흔 네 번째 포스팅

안녕하세요! 마흔 네 번째 포스팅으로 찾아뵙게 되어 반갑습니다!♥

오늘의 포스팅 내용은 **프로그래머스 - 게임 맵 최단거리**에 관한 내용입니다. <br/>
자세한 내용을 알아보러 갑시다❗️

**[Boongranii] Here We Go 🔥**

---

# 1️⃣ 문제

[**[프로그래머스] 게임 맵 최단거리 (문제 링크)**](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

## 💨 **문제 설명**

ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.

지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/700827ff-0c2e-419f-bd1f-176d11f5ecb5) <br>

위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.

- 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/9a39b6cc-e675-4022-8d05-6f091aeb6646) <br>

- 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/26cb9421-b6fc-499f-a31c-67fee80c93af) <br>

위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.

만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/607dc06b-d1f0-4a23-af2b-3bae4b423772) <br>

게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.

## 💨 **제한 사항**

- maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
  - n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
- maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
- 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.

## 💨 **입출력 예**

|                             maps                              | answer |
| :-----------------------------------------------------------: | :----: |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] |   11   |
| [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] |   -1   |

## 💨 **입출력 예 설명**

**입출력 예 #1** <br>

주어진 데이터는 다음과 같습니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/cfe24d50-535c-42c6-8cc3-05206c03932a) <br>

캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.

![image](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/fe43a95b-1c28-4bd4-bced-54196a50fe46) <br>

따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.

**입출력 예 #2** <br>

문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.

---

# 2️⃣ 문제 풀이

## 🔥 나의 문제 풀이

> 1. 최단 경로를 찾아야 함.
> 2. 왼쪽으로 가면 -1, 오른쪽이면 1, 위로 가면 -1, 아래로 가면 +1
> 3. 초기값은 (0,0)에서 시작하며 시작위치도 counting해서 1부터 시작함.
> 4. 도착지점은 (n-1, m-1)
> 5. 도착지점에 도달하면 count를 반환함.
> 6. 게임 맵을 벗어났을 때와 벽일 때 고려함.
> 7. 방문한 곳은 다시 방문하지 않도록 함.

```js
function solution(maps) {
  const n = maps.length;
  const m = maps[0].length;
  const dx = [-1, 1, 0, 0]; // 서, 동, 북, 남
  const dy = [0, 0, -1, 1]; // 서, 동, 북, 남
  const arr = [[0, 0, 1]]; // x, y, count

  while (arr.length > 0) {
    const [x, y, count] = arr.shift();
    // 게임 목표 지점에 도달했을 때
    if (x === n - 1 && y === m - 1) {
      return count;
    }
    for (let i = 0; i < 4; i++) {
      const nx = x + dx[i];
      const ny = y + dy[i];

      // 게임 맵을 벗어났을 때
      if (nx < 0 || nx >= n || ny < 0 || ny >= m) {
        continue;
      }
      // 벽일 때
      if (maps[nx][ny] === 0) {
        continue;
      }
      // 방문한 곳이면 무시
      if (maps[nx][ny] === "방문") {
        continue;
      }

      maps[nx][ny] = "방문";
      arr.push([nx, ny, count + 1]);
      //   console.log(maps[nx][ny]);
    }
  }
  return -1;
}

console.log(
  solution([
    [1, 0, 1, 1, 1],
    [1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1],
    [1, 1, 1, 0, 1],
    [0, 0, 0, 0, 1],
  ])
);
```

너비 우선 탐색(BFS) 알고리즘을 사용하여 최단 경로를 찾는 문제이다. 출발 지점부터 인접한 모든 정점을 탐색하며, 최단 경로를 찾는 효율적인 방법이라고 할 수 있다.

주어진 2차원 배열에서 시작점을 (0, 0) 으로 잡고 목표 지점 (n-1, m-1) 까지 반복문을 통해 순회를 한다.

출발 지점부터 인접한 지점들을 탐색하고, 방문하지 않은 지점이면 배열 안에 넣고 `방문`이라고 표시를 하였다. 그리고 그 배열에서 꺼낸 지점에서 다시 인접 지점들을 탐색하여 이동 거리를 증가시키며 확인한다.

`게임 맵을 벗어났을 때`, `벽일 때`, `이미 방문한 곳`일 경우에는 무시하도록 해야한다.

주어진 문제에서 벽은 0이고 이동 가능한 경로는 1이므로 적절하게 처리해야 한다.

결론은 게임 맵에서 출발 지점부터 목표 지점까지의 최단 이동 거리를 반환하는 것이다. 아니라면 -1을 반환하는 문제였다.

---

# 3️⃣ 느낀점

이 문제와 비슷한 문제를 풀어봤던 것 같다.

[**[Lv.0-안전지대]**](https://school.programmers.co.kr/learn/courses/30/lessons/120866) 이 문제는 BFS는 아니지만 비슷한 느낌이 있다. ~~아님 말고.~~

문제를 풀면서 목표 지점에 도달하기 위해 무작정 이동하는 것이 아니라, 가능한 모든 경로를 고려하고 최단 경로를 찾아야 하기 때문에 BFS를 택하게 됐다.

고려해야 할 조건들이 많았지만 문제를 꼼꼼히 읽으며 추가했다. 사실 저 위에 조건문들은 하나로 다 묶어도 된다. 하지만 가독성을 위해서 따로 나누었다. 이게 읽기 편한 코드이긴 한 것 같다.

알고리즘을 활용해서 해결해야 하는 문제는 전략과 생각을 많이 해야 하는 것 같다. 어렵네 엫효효효😩

그럼 빠이✌️
