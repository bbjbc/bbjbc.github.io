---
title: "[Algorithm] 튜플"
categories: [algorithm]
tags: [algorithm, programmers, Lv2, 2019 카카오 개발자 겨울 인턴십]
author-profile: true
sidebar_main: true
main: true
toc: true
toc_sticky: true
---

# 서른 여덟 번째 포스팅

안녕하세요! 서른 여덟 번째 포스팅으로 찾아뵙게 되어 반갑습니다!♥

오늘의 포스팅 내용은 **프로그래머스 - 튜플**에 관한 내용입니다. <br/>
자세한 내용을 알아보러 갑시다❗️

**[Boongranii] Here We Go 🔥**

---

# 1️⃣ 문제

[**[프로그래머스] 튜플 (문제 링크)**](https://school.programmers.co.kr/learn/courses/30/lessons/64065)

## 💨 **문제 설명**

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

- (a1, a2, a3, ..., an)

튜플은 다음과 같은 성질을 가지고 있습니다.

1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, <u>중복되는 원소가 없는</u> 튜플 `(a1, a2, a3, ..., an)`이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

- {% raw %} {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}} {% endraw %}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

- {% raw %} {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {% endraw %}

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

- {% raw %} {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {% endraw %}
- {% raw %} {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}} {% endraw %}
- {% raw %} {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}} {% endraw %}

는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

## 💨 **제한사항**

- s의 길이는 5 이상 1,000,000 이하입니다.
- s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
- 숫자가 0으로 시작하는 경우는 없습니다.
- s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
- s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
- return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

## 💨 **입출력 예**

|                           s                            |    result    |
| :----------------------------------------------------: | :----------: |
| {% raw %} "{{2},{2,1},{2,1,3},{2,1,3,4}}" {% endraw %} | [2, 1, 3, 4] |
| {% raw %} "{{1,2,3},{2,1},{1,2,4,3},{2}}" {% endraw %} | [2, 1, 3, 4] |
|       {% raw %} "{{20,111},{111}}" {% endraw %}        |  [111, 20]   |
|            {% raw %} "{{123}}" {% endraw %}            |    [123]     |
| {% raw %} "{{4,2,3},{3},{2,3,4,1},{2,3}}" {% endraw %} | [3, 2, 4, 1] |

## 💨 **입출력 예 설명**

**입출력 예 #1** <br>

- 문제 예시와 같습니다.

**입출력 예 #2** <br>

- 문제 예시와 같습니다.

**입출력 예 #3** <br>

- (111, 20)을 집합 기호를 이용해 표현하면 {% raw %} {{111}, {111,20}} 이 되며, 이는 {{20,111},{111}}과 같습니다. {% endraw %}

**입출력 예 #4** <br>

- (123)을 집합 기호를 이용해 표현하면 {% raw %} {{123}} 입니다. {% endraw %}

**입출력 예 #5** <br>

- (3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {% raw %} {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다. {% endraw %}

---

# 2️⃣ 문제 풀이

## 🔥 나의 문제 풀이

{% raw %}

> 1. {{2},{2,1},{2,1,3},{2,1,3,4}}
> 2. 2},{2,1},{2,1,3},{2,1,3,4
> 3. [ '2', '2,1', '2,1,3', '2,1,3,4' ]
> 4. [ [ '2' ], [ '2', '1' ], [ '2', '1', '3' ], [ '2', '1', '3', '4' ] ]
> 5. [ [ 2 ], [ 2, 1 ], [ 2, 1, 3 ], [ 2, 1, 3, 4 ] ]
> 6. 길이 순으로 오름차순 정렬
> 7. 요소 탐색하면서 없던 요소면 result에 삽입

{% endraw %}

```js
function solution(s) {
  const result = [];

  s = s
    .slice(2, s.length - 2)
    .split("},{")
    .map((a) => a.split(","));
  s = s.map((a) => a.map((a) => +a));

  s.sort((a, b) => a.length - b.length);

  s.forEach((el) => {
    el.forEach((e) => {
      if (!result.includes(e)) {
        result.push(e);
      }
    });
  });

  return result;
}
```

주어진 예시는 객체가 아니라 객체 형태의 문자열이다. 객체라고 생각하고 `Object.values()`를 사용하여 배열로 바꾸려고 했지만 문자열이기에 불가능했다.

따라서 중괄호를 모두 없애고 배열로 바꾸는 과정이 필요하다.

> **맨 양 끝 중괄호 제거**

```js
s = s.slice(2, s.length - 2);
```

![tuple](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/c3d7cd23-7834-4a77-a7b7-d32277ba59f8) <br>

위와 같은 모습이다.

> **사이에 있는 중괄호와 콤마를 기준으로 배열화**

```js
s = s.slice(2, s.length - 2).split("},{");
```

![tuple2](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/dc6b5a57-8f1b-4a37-96ef-21b92f857da9) <br>

위와 같은 모습으로 배열이 된다.

> **콤마별로 배열화**

```js
s = s
  .slice(2, s.length - 2)
  .split("},{")
  .map((a) => a.split(","));
```

![tuple3](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/40b851d0-58bc-4d29-b4da-90a230ed2e7c) <br>

위와 같은 모습으로 분리가 된다.

> **각 요소를 숫자화**

```js
s = s.map((a) => a.map((a) => +a));
```

![tuple4](https://github.com/bbjbc/bbjbc.github.io/assets/102457140/2e867488-28cb-467e-bee0-b1c48e8f0926) <br>

이제 모든 숫자가 알맞게 분리가 되었다.

배열의 길이별로 정렬을 해주고, 길이가 짧을수록 결과 배열의 앞 요소 자리에 차지하게 된다. 그래서 넣었던 숫자를 제외한 숫자를 차근차근 넣어주면 된다.

---

# 3️⃣ 느낀점

흥미로운 문제였다. 주어진 문자열을 배열화하는 것이 문제의 목적이었던 것 같다.

처음에는 어떻게 분리할까 `split()`으로 해볼까 하다가 되지 않아서 차근차근 분리해봤다. 그 후 아이디어는 주어진 예제를 계속 바라보면 어떻게 해결할 지 알 수 있을 것이다. **그럼 안녕핑🐌**
