---
title: "[Algorithm] 큰 수 만들기"
categories: [algorithm]
tags: [algorithm, programmers, Lv2, greedy]
author-profile: true
sidebar_main: true
main: true
toc: true
toc_sticky: true
---

# 서른 두 번째 포스팅

안녕하세요! 서른 두 번째 포스팅으로 찾아뵙게 되어 반갑습니다!♥

오늘의 포스팅 내용은 **프로그래머스 - 큰 수 만들기**에 관한 내용입니다. <br/>
자세한 내용을 알아보러 갑시다❗️

**[Boongranii] Here We Go 🔥**

---

# 1️⃣ 문제

[**[프로그래머스] 큰 수 만들기 (문제 링크)**](https://school.programmers.co.kr/learn/courses/30/lessons/42883)

## 💨 **문제 설명**

어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

## 💨 **제한사항**

- number는 2자리 이상, 1,000,000자리 이하인 숫자입니다.
- k는 1 이상 `number의 자릿수` 미만인 자연수입니다.

## 💨 **입출력 예**

|    number    |  k  |  return  |
| :----------: | :-: | :------: |
|    "1924"    |  2  |   "94"   |
|  "1231234"   |  3  |  "3234"  |
| "4177252841" |  4  | "775841" |

---

# 2️⃣ 문제 풀이

## 🔥 문제 풀이

> 1. 값을 비교해 가면서 작은 값을 추출 해야 함.
> 2. number를 순회하며 arr의 마지막 원소가 number값보다 작으면 pop()
> 3. pop() 했으니 k도 감소 시킴.
> 4. 그게 아니라면 arr에 push()
> 5. "3333222111" 과 같은 TC가 있기 때문에 k가 남아있을 수 있음.
> 6. 그래서 k가 남아있으면 k만큼 arr에서 pop() 해줌.
> 7. arr를 join() 해서 리턴.

```js
function solution(number, k) {
  const arr = [];

  for (let i = 0; i < number.length; i++) {
    while (arr[arr.length - 1] < number[i] && k) {
      arr.pop();
      k--;
    }
    arr.push(number[i]);
  }

  if (k) {
    for (let i = 0; i < k; i++) {
      arr.pop();
    }
  }

  return arr.join("");
}
```

처음에 문제를 접했을 때는 그냥 가장 작은 값 k개 추출하고 문자열 제일 크게 만들기 문제인 줄 알았다. 하지만 그건 아니었다. ㅋ

[**[택배 상자]**](https://bbjbc.github.io/algorithm/twenty-fourth-posting/) <br>

문제를 풀다가 로직이 "어 내가 풀어봤던 로직인데,," 했더니 위 문제와 비슷한 로직으로 풀었던 것 같다. 생각하는 건 문제가 다르니 다른 문제 같았지만 코드를 보면서 뭔가 비슷하다는 느낌을 받았다. ~~아님 말고다.~~

다른 테스트 케이스는 잘 통과 되는데 마지막 TC만 통과가 계속 안됐다. 그래서 질문하기를 참조했는데 역시나 12번 케이스가 통과 안된다는 질문이 다수 존재했다. 간단했다.

`"3333222111"`과 같은 케이스가 존재해서 `while`문에 들어가지 못해서 `k`가 감소하지 않는 경우이다. 그래서 `for`문이 종료된 후에 `k`가 남아있다면 `k`개 만큼 `pop()`을 해주었다.

---

# 3️⃣ 느낀점

질문하기는 언제나 참조할 수 있다. 하지만, 질문하기를 참조하지 않고도 TC를 유추해서 예외의 경우를 생각해야 정말 미친놈이 될 것이라고 생각한다. ~~근데 그게 어려운 걸 어떡해?~~

그냥 이것 저것 풀다 보면 보이게 될 것이다. 코드도 계속 반복하면 이것을 써야 하고 저것을 써야 하는 것이다. 마치, 수학처럼 여러 번 풀다 보면 익숙해져서 문제를 어떻게 풀어갈 것인지도 쉽게 파악할 수 있을 것이다.

**그니까 반복이 답이다.** **그럼 안녕핑🐌**
